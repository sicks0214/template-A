# 模块化功能页面快速接入指南

> **基于方案A：模块化路由接入的标准化流程**  
> **适用于前后端分离架构 (React + Express)**  
> **版本**: v1.0  
> **最后更新**: 2025-10-03

---

## 📋 目录

1. [快速开始](#快速开始)
2. [模块结构规范](#模块结构规范)
3. [前端接入流程](#前端接入流程)
4. [后端接入流程](#后端接入流程)
5. [配置和注册](#配置和注册)
6. [部署和验证](#部署和验证)
7. [最佳实践](#最佳实践)
8. [故障排查](#故障排查)

---

## 🚀 快速开始

### 核心原则

```
❌ 不使用404页面作为功能入口
✅ 使用模块化路由配置 + 动态注册
✅ 前端React Router + 后端Express Router
✅ 统一的模块配置和管理
```

### 5分钟快速接入

```bash
# 1. 创建模块（使用脚本）
./scripts/create-new-module.sh my-feature

# 2. 编写功能代码
# - frontend/pages/MyFeaturePage.tsx
# - backend/routes/myFeatureRoutes.ts

# 3. 注册模块
# - 编辑 template-config/module.registry.ts

# 4. 部署
npm run build && ./scripts/one-click-deploy.sh
```

---

## 📁 模块结构规范

### 标准模块目录结构

```
modules/
└── {module-name}/              # 模块名称（小写，用连字符分隔）
    ├── frontend/               # 前端代码
    │   ├── pages/             # 页面组件
    │   │   └── {ModuleName}Page.tsx
    │   ├── components/        # 模块专用组件
    │   │   └── {ComponentName}.tsx
    │   ├── hooks/             # 模块专用Hooks
    │   │   └── use{Feature}.ts
    │   ├── types/             # TypeScript类型定义
    │   │   └── index.ts
    │   └── styles/            # 模块样式（可选）
    │       └── {module}.css
    │
    ├── backend/               # 后端代码
    │   ├── routes/            # API路由
    │   │   └── {module}Routes.ts
    │   ├── controllers/       # 控制器
    │   │   └── {module}Controller.ts
    │   ├── services/          # 业务逻辑
    │   │   └── {module}Service.ts
    │   ├── middleware/        # 中间件（可选）
    │   │   └── {module}Middleware.ts
    │   └── types/             # TypeScript类型
    │       └── index.ts
    │
    ├── database/              # 数据库脚本（可选）
    │   └── {module}_tables.sql
    │
    ├── i18n/                  # 国际化（可选）
    │   └── locales/
    │       ├── zh.json
    │       ├── en.json
    │       └── ...
    │
    ├── module.config.ts       # ⭐ 模块配置文件（必需）
    └── README.md             # 模块说明文档
```

### 模块命名规范

| 类型 | 命名规则 | 示例 |
|------|---------|------|
| 模块目录 | kebab-case | `user-profile`, `color-analysis` |
| 前端页面组件 | PascalCase + Page | `UserProfilePage.tsx` |
| 后端路由文件 | camelCase + Routes | `userProfileRoutes.ts` |
| API路径 | kebab-case | `/api/user-profile` |
| 前端路由路径 | kebab-case | `/user-profile` |

---

## 🎨 前端接入流程

### 步骤1: 创建页面组件

```typescript
// modules/my-feature/frontend/pages/MyFeaturePage.tsx
import React from 'react'
import { useTranslation } from 'react-i18next'
import { useNavigate } from 'react-router-dom'

export const MyFeaturePage: React.FC = () => {
  const { t } = useTranslation()
  const navigate = useNavigate()

  return (
    <div className="my-feature-page">
      <h1>{t('myFeature.title')}</h1>
      <p>{t('myFeature.description')}</p>
      
      {/* 功能实现 */}
      <div className="feature-content">
        {/* ... */}
      </div>

      <button onClick={() => navigate('/')}>
        {t('common.backToHome')}
      </button>
    </div>
  )
}
```

### 步骤2: 创建模块专用组件（可选）

```typescript
// modules/my-feature/frontend/components/FeatureCard.tsx
import React from 'react'

interface FeatureCardProps {
  title: string
  description: string
  onClick?: () => void
}

export const FeatureCard: React.FC<FeatureCardProps> = ({
  title,
  description,
  onClick
}) => {
  return (
    <div className="feature-card" onClick={onClick}>
      <h3>{title}</h3>
      <p>{description}</p>
    </div>
  )
}
```

### 步骤3: 创建类型定义

```typescript
// modules/my-feature/frontend/types/index.ts
export interface FeatureData {
  id: string
  title: string
  content: string
  createdAt: Date
  updatedAt?: Date
}

export interface FeatureResponse {
  success: boolean
  data: FeatureData
  message?: string
}
```

### 步骤4: 创建API调用服务（可选）

```typescript
// modules/my-feature/frontend/services/featureService.ts
import axios from 'axios'
import type { FeatureData, FeatureResponse } from '../types'

const API_BASE = '/api/my-feature'

export const featureService = {
  // 获取数据
  async getData(id: string): Promise<FeatureData> {
    const response = await axios.get<FeatureResponse>(`${API_BASE}/${id}`)
    return response.data.data
  },

  // 创建数据
  async createData(data: Partial<FeatureData>): Promise<FeatureData> {
    const response = await axios.post<FeatureResponse>(API_BASE, data)
    return response.data.data
  },

  // 更新数据
  async updateData(id: string, data: Partial<FeatureData>): Promise<FeatureData> {
    const response = await axios.put<FeatureResponse>(`${API_BASE}/${id}`, data)
    return response.data.data
  },

  // 删除数据
  async deleteData(id: string): Promise<void> {
    await axios.delete(`${API_BASE}/${id}`)
  }
}
```

---

## 🔧 后端接入流程

### 步骤1: 创建路由文件

```typescript
// modules/my-feature/backend/routes/myFeatureRoutes.ts
import express from 'express'
import { myFeatureController } from '../controllers/myFeatureController'
import { authMiddleware } from '../../../backend/src/middleware/auth'

const router = express.Router()

// 公开路由
router.get('/public', myFeatureController.getPublicData)

// 受保护路由（需要认证）
router.use(authMiddleware) // 所有后续路由需要认证

router.get('/:id', myFeatureController.getData)
router.post('/', myFeatureController.createData)
router.put('/:id', myFeatureController.updateData)
router.delete('/:id', myFeatureController.deleteData)

export default router
```

### 步骤2: 创建控制器

```typescript
// modules/my-feature/backend/controllers/myFeatureController.ts
import { Request, Response } from 'express'
import { myFeatureService } from '../services/myFeatureService'

export const myFeatureController = {
  // 获取数据
  async getData(req: Request, res: Response) {
    try {
      const { id } = req.params
      const data = await myFeatureService.getData(id)
      
      res.json({
        success: true,
        data,
        message: '获取成功'
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      })
    }
  },

  // 创建数据
  async createData(req: Request, res: Response) {
    try {
      const userId = req.user?.id // 从认证中间件获取
      const data = await myFeatureService.createData({
        ...req.body,
        userId
      })
      
      res.status(201).json({
        success: true,
        data,
        message: '创建成功'
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      })
    }
  },

  // 更新数据
  async updateData(req: Request, res: Response) {
    try {
      const { id } = req.params
      const data = await myFeatureService.updateData(id, req.body)
      
      res.json({
        success: true,
        data,
        message: '更新成功'
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      })
    }
  },

  // 删除数据
  async deleteData(req: Request, res: Response) {
    try {
      const { id } = req.params
      await myFeatureService.deleteData(id)
      
      res.json({
        success: true,
        message: '删除成功'
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      })
    }
  },

  // 公开接口
  async getPublicData(req: Request, res: Response) {
    try {
      const data = await myFeatureService.getPublicData()
      res.json({ success: true, data })
    } catch (error) {
      res.status(500).json({ success: false, message: error.message })
    }
  }
}
```

### 步骤3: 创建服务层

```typescript
// modules/my-feature/backend/services/myFeatureService.ts
import { databaseService } from '../../../backend/src/services/database/databaseServiceFactory'
import { AUTH_TABLES } from '../../../backend/src/config/tables'

// 模块表名（使用TABLE_PREFIX）
const TABLE_PREFIX = process.env.TABLE_PREFIX || ''
const FEATURE_TABLE = `${TABLE_PREFIX}my_feature_data`

export const myFeatureService = {
  async getData(id: string) {
    const query = `
      SELECT * FROM ${FEATURE_TABLE}
      WHERE id = $1
    `
    const result = await databaseService.query(query, [id])
    
    if (result.rows.length === 0) {
      throw new Error('数据不存在')
    }
    
    return result.rows[0]
  },

  async createData(data: any) {
    const query = `
      INSERT INTO ${FEATURE_TABLE} (title, content, user_id, created_at)
      VALUES ($1, $2, $3, NOW())
      RETURNING *
    `
    const result = await databaseService.query(query, [
      data.title,
      data.content,
      data.userId
    ])
    
    return result.rows[0]
  },

  async updateData(id: string, data: any) {
    const query = `
      UPDATE ${FEATURE_TABLE}
      SET title = $1, content = $2, updated_at = NOW()
      WHERE id = $3
      RETURNING *
    `
    const result = await databaseService.query(query, [
      data.title,
      data.content,
      id
    ])
    
    if (result.rows.length === 0) {
      throw new Error('数据不存在')
    }
    
    return result.rows[0]
  },

  async deleteData(id: string) {
    const query = `DELETE FROM ${FEATURE_TABLE} WHERE id = $1`
    await databaseService.query(query, [id])
  },

  async getPublicData() {
    const query = `
      SELECT id, title, created_at 
      FROM ${FEATURE_TABLE}
      WHERE is_public = true
      ORDER BY created_at DESC
      LIMIT 10
    `
    const result = await databaseService.query(query, [])
    return result.rows
  }
}
```

### 步骤4: 创建数据库表（可选）

```sql
-- modules/my-feature/database/myfeature_tables.sql

-- 使用表前缀（从环境变量获取）
-- 实际部署时会替换为：site3__my_feature_data

CREATE TABLE IF NOT EXISTS {TABLE_PREFIX}my_feature_data (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES {TABLE_PREFIX}users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    is_public BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_myfeature_user ON {TABLE_PREFIX}my_feature_data(user_id);
CREATE INDEX idx_myfeature_public ON {TABLE_PREFIX}my_feature_data(is_public, created_at);

-- 授予站点用户权限
GRANT ALL PRIVILEGES ON {TABLE_PREFIX}my_feature_data TO {SITE_USER};
GRANT USAGE, SELECT ON SEQUENCE {TABLE_PREFIX}my_feature_data_id_seq TO {SITE_USER};
```

---

## ⚙️ 配置和注册

### 步骤1: 创建模块配置文件

```typescript
// modules/my-feature/module.config.ts
import { ModuleConfig } from '../../template-config/types'
import myFeatureRoutes from './backend/routes/myFeatureRoutes'

const myFeatureConfig: ModuleConfig = {
  // 基本信息
  id: 'my-feature',
  name: '我的功能模块',
  description: '这是一个示例功能模块',
  version: '1.0.0',
  author: 'Your Name',
  
  // 前端路由配置
  routes: [
    {
      path: '/my-feature',
      component: () => import('./frontend/pages/MyFeaturePage'),
      meta: {
        requireAuth: false,  // 是否需要认证
        title: '我的功能',
        icon: 'feature-icon'
      }
    },
    {
      path: '/my-feature/:id',
      component: () => import('./frontend/pages/MyFeatureDetailPage'),
      meta: {
        requireAuth: true,
        title: '功能详情'
      }
    }
  ],
  
  // 后端路由
  backendRoutes: myFeatureRoutes,
  
  // API路径前缀
  apiPrefix: '/api/my-feature',
  
  // 数据库表配置
  database: {
    tables: ['my_feature_data'],
    initScript: './database/myfeature_tables.sql'
  },
  
  // 国际化配置
  i18n: {
    namespaces: ['myFeature'],
    locales: ['zh', 'en', 'ja', 'ko']
  },
  
  // 权限配置（可选）
  permissions: {
    read: 'my-feature:read',
    write: 'my-feature:write',
    delete: 'my-feature:delete'
  },
  
  // 依赖的其他模块（可选）
  dependencies: [],
  
  // 关键词（用于搜索和推荐）
  keywords: ['feature', 'example', '功能', '示例'],
  
  // 是否启用
  enabled: true
}

export default myFeatureConfig
```

### 步骤2: 注册到模块注册器

```typescript
// template-config/module.registry.ts
import exampleSimpleConfig from '../modules/example-simple/module.config'
import colorAnalysisConfig from '../modules/color-analysis/module.config'
import myFeatureConfig from '../modules/my-feature/module.config'  // 导入新模块

export class ModuleRegistry {
  // 可用模块映射
  static availableModules = new Map<string, ModuleConfig>([
    ['example-simple', exampleSimpleConfig],
    ['color-analysis', colorAnalysisConfig],
    ['my-feature', myFeatureConfig],  // ⭐ 注册新模块
  ])
  
  // 激活的模块列表
  static activeModules: string[] = [
    'example-simple',
    'color-analysis',
    'my-feature',  // ⭐ 激活新模块
  ]
  
  // 获取所有激活的模块配置
  static getActiveModules(): ModuleConfig[] {
    return this.activeModules
      .map(name => this.availableModules.get(name))
      .filter(config => config?.enabled)
  }
  
  // 获取模块路由
  static getModuleRoutes() {
    const routes = []
    
    this.getActiveModules().forEach(config => {
      if (config.routes) {
        routes.push(...config.routes)
      }
    })
    
    return routes
  }
  
  // 获取模块API路由
  static getModuleApiRoutes() {
    const apiRoutes = new Map()
    
    this.getActiveModules().forEach(config => {
      if (config.backendRoutes) {
        apiRoutes.set(config.apiPrefix, config.backendRoutes)
      }
    })
    
    return apiRoutes
  }
}
```

### 步骤3: 前端App集成

```typescript
// frontend/src/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import { ModuleRegistry } from '../template-config/module.registry'
import { Suspense, lazy } from 'react'

// 核心页面
import HomePage from './pages/HomePage'
import NotFoundPage from './pages/NotFoundPage'

// 懒加载模块页面
const loadModuleComponent = (importFn: () => Promise<any>) => {
  return lazy(importFn)
}

function App() {
  // 获取所有模块路由
  const moduleRoutes = ModuleRegistry.getModuleRoutes()

  return (
    <BrowserRouter>
      <Suspense fallback={<div>加载中...</div>}>
        <Routes>
          {/* 核心路由 */}
          <Route path="/" element={<HomePage />} />
          
          {/* 动态加载模块路由 */}
          {moduleRoutes.map(route => {
            const Component = loadModuleComponent(route.component)
            
            return (
              <Route
                key={route.path}
                path={route.path}
                element={
                  route.meta?.requireAuth ? (
                    <ProtectedRoute>
                      <Component />
                    </ProtectedRoute>
                  ) : (
                    <Component />
                  )
                }
              />
            )
          })}
          
          {/* 404页面（必须放在最后） */}
          <Route path="*" element={<NotFoundPage />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  )
}

export default App
```

### 步骤4: 后端App集成

```typescript
// backend/src/index.ts
import express from 'express'
import path from 'path'
import cors from 'cors'
import { ModuleRegistry } from '../../template-config/module.registry'

const app = express()

// 中间件
app.use(cors())
app.use(express.json())

// ⚙️ 路由优先级配置（重要！）

// 1. 健康检查（最高优先级）
app.get('/health', (req, res) => {
  res.json({ success: true, status: 'healthy' })
})

// 2. 核心API路由
app.use('/api/auth', authRoutes)
app.use('/api/feedback', feedbackRoutes)

// 3. 动态注册模块API路由
const moduleApiRoutes = ModuleRegistry.getModuleApiRoutes()
moduleApiRoutes.forEach((router, apiPrefix) => {
  console.log(`📍 注册模块路由: ${apiPrefix}`)
  app.use(apiPrefix, router)
})

// 4. 静态文件服务（生产环境）
if (process.env.NODE_ENV === 'production') {
  const frontendPath = path.join(__dirname, 'frontend/dist')
  app.use(express.static(frontendPath))
  
  // 5. SPA路由支持（优先级最低）
  app.get('*', (req, res, next) => {
    // API路由跳过
    if (req.path.startsWith('/api') || req.path === '/health') {
      return next()
    }
    // 返回index.html，让前端路由接管
    res.sendFile(path.join(frontendPath, 'index.html'))
  })
}

// 启动服务器
const PORT = process.env.PORT || 3000
app.listen(PORT, () => {
  console.log(`🚀 服务器运行在端口 ${PORT}`)
  console.log(`📊 已加载 ${moduleApiRoutes.size} 个模块`)
})
```

---

## 🚢 部署和验证

### 步骤1: 本地开发测试

```bash
# 前端开发模式
cd frontend
npm run dev
# 访问: http://localhost:5173/my-feature

# 后端开发模式（另一个终端）
cd backend
npm run dev
# API: http://localhost:3000/api/my-feature
```

### 步骤2: 本地构建验证

```bash
# 1. 编译TypeScript（后端）
cd backend
npm run build

# 验证编译成功
ls -la dist/
grep "my-feature" dist/index.js

# 2. 构建前端
cd ../frontend
npm run build

# 验证构建成功
ls -la dist/
cat dist/index.html | grep "my-feature"

# 3. 复制前端到后端
cp -r dist ../backend/frontend/
```

### 步骤3: Git提交

```bash
# 提交所有修改
git add modules/my-feature/
git add template-config/module.registry.ts
git add frontend/src/App.tsx
git add backend/src/index.ts
git add backend/dist/

git commit -m "feat: add my-feature module with full frontend and backend integration"
git push origin main
```

### 步骤4: VPS部署

```bash
# 在VPS上操作
cd /docker/siteN  # N为你的站点编号

# 1. 备份配置
cp backend/.env backend/.env.backup

# 2. 拉取代码
git pull origin main

# 3. 恢复配置
cp backend/.env.backup backend/.env

# 4. 初始化数据库表（如果有）
docker exec postgres_master psql -U admin -d postgres <<EOF
-- 替换TABLE_PREFIX和SITE_USER
\set TABLE_PREFIX 'site3__'
\set SITE_USER 'site3_user'
\i /path/to/modules/my-feature/database/myfeature_tables.sql
EOF

# 5. 一键部署
./scripts/one-click-deploy-postgres.sh
```

### 步骤5: 验证部署

```bash
# 1. 检查容器状态
docker ps | grep siteN

# 2. 查看日志
docker logs siteN --tail 50
# 应该看到：📍 注册模块路由: /api/my-feature

# 3. 测试API
curl http://localhost:3000/api/my-feature/public
# 预期：{"success":true,"data":[...]}

# 4. 测试前端路由（通过Nginx）
curl -I https://yourdomain.com/my-feature
# 预期：HTTP/1.1 200 OK

# 5. 完整功能测试
# 访问浏览器：https://yourdomain.com/my-feature
```

---

## 📚 最佳实践

### 1. 模块独立性原则

✅ **DO**:
- 模块代码自包含，不依赖其他模块的内部实现
- 通过module.config.ts统一配置
- 使用标准化的接口和类型
- 数据库表使用模块前缀

❌ **DON'T**:
- 直接导入其他模块的内部组件
- 硬编码模块路径或API地址
- 跨模块直接操作数据库
- 循环依赖其他模块

### 2. 路由命名规范

```typescript
// ✅ 正确
const routes = [
  { path: '/user-profile', component: UserProfilePage },
  { path: '/color-analysis', component: ColorAnalysisPage },
  { path: '/my-feature', component: MyFeaturePage }
]

// ❌ 错误
const routes = [
  { path: '/userProfile', component: UserProfilePage },  // 不使用驼峰
  { path: '/Color_Analysis', component: ColorAnalysisPage },  // 不用下划线和大写
  { path: '/feature', component: MyFeaturePage }  // 太通用，容易冲突
]
```

### 3. API设计规范

```typescript
// ✅ RESTful风格
GET    /api/my-feature           # 列表
GET    /api/my-feature/:id       # 详情
POST   /api/my-feature           # 创建
PUT    /api/my-feature/:id       # 更新
DELETE /api/my-feature/:id       # 删除

// ✅ 响应格式统一
{
  "success": true | false,
  "data": any,
  "message": "操作结果说明",
  "error": "错误信息（可选）"
}
```

### 4. 错误处理

```typescript
// 前端错误处理
try {
  const data = await featureService.getData(id)
  // 处理成功
} catch (error) {
  if (error.response?.status === 404) {
    // 数据不存在
    showNotification('数据不存在', 'error')
  } else if (error.response?.status === 401) {
    // 未授权
    navigate('/login')
  } else {
    // 其他错误
    showNotification('操作失败，请稍后重试', 'error')
  }
}

// 后端错误处理
try {
  const data = await myFeatureService.getData(id)
  res.json({ success: true, data })
} catch (error) {
  console.error('Error in getData:', error)
  
  if (error.message === '数据不存在') {
    res.status(404).json({ success: false, message: error.message })
  } else {
    res.status(500).json({ success: false, message: '服务器内部错误' })
  }
}
```

### 5. 类型安全

```typescript
// ✅ 共享类型定义
// shared/types/modules.ts
export interface ModuleRoute {
  path: string
  component: () => Promise<any>
  meta?: {
    requireAuth?: boolean
    title?: string
    icon?: string
  }
}

export interface ModuleConfig {
  id: string
  name: string
  version: string
  routes: ModuleRoute[]
  backendRoutes?: any
  apiPrefix: string
  enabled: boolean
}

// 前端使用
import type { ModuleRoute } from '../../../shared/types/modules'

// 后端使用
import type { ModuleConfig } from '../../../shared/types/modules'
```

### 6. 数据库表设计

```sql
-- ✅ 使用表前缀
CREATE TABLE {TABLE_PREFIX}my_feature_data (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES {TABLE_PREFIX}users(id),
    -- 使用统一的时间戳字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ✅ 创建必要的索引
CREATE INDEX idx_{TABLE_PREFIX}myfeature_user ON {TABLE_PREFIX}my_feature_data(user_id);

-- ✅ 授予正确的权限
GRANT ALL PRIVILEGES ON {TABLE_PREFIX}my_feature_data TO {SITE_USER};
```

### 7. 国际化支持

```typescript
// 前端组件
import { useTranslation } from 'react-i18next'

const MyFeaturePage = () => {
  const { t } = useTranslation('myFeature')  // 使用模块命名空间
  
  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
    </div>
  )
}

// i18n配置文件
// modules/my-feature/i18n/locales/zh.json
{
  "myFeature": {
    "title": "我的功能",
    "description": "这是功能描述",
    "actions": {
      "create": "创建",
      "edit": "编辑",
      "delete": "删除"
    }
  }
}
```

---

## 🔍 故障排查

### 问题1: 模块路由404

**症状**：访问 `/my-feature` 返回404

**排查步骤**：
```bash
# 1. 检查模块是否注册
cat template-config/module.registry.ts | grep "my-feature"

# 2. 检查模块是否激活
cat template-config/module.registry.ts | grep -A 5 "activeModules"

# 3. 检查前端构建
ls -la frontend/dist/assets/*.js | head -5
grep -r "my-feature" frontend/dist/assets/*.js

# 4. 检查后端路由注册日志
docker logs siteN | grep "注册模块路由"
```

**解决方案**：
1. 确保模块已添加到 `availableModules`
2. 确保模块ID在 `activeModules` 列表中
3. 重新构建前端：`npm run build`
4. 重新部署：`./scripts/one-click-deploy.sh`

### 问题2: API调用失败

**症状**：前端调用API返回404或500

**排查步骤**：
```bash
# 1. 检查API路由注册
docker logs siteN | grep "my-feature"

# 2. 测试API端点
docker exec siteN curl http://localhost:3000/api/my-feature/public

# 3. 检查CORS配置
docker logs siteN | grep "CORS"

# 4. 检查环境变量
docker exec siteN env | grep -E "(ALLOWED_ORIGINS|DB_)"
```

**解决方案**：
1. 确认 `apiPrefix` 配置正确
2. 确认后端路由已导出：`export default router`
3. 检查CORS配置包含前端域名
4. 检查数据库连接和表是否存在

### 问题3: 数据库表不存在

**症状**：API调用报错 "relation does not exist"

**排查步骤**：
```bash
# 1. 检查表是否存在
docker exec postgres_master psql -U admin -d postgres -c "\dt site3__my_feature*"

# 2. 检查TABLE_PREFIX配置
docker exec siteN env | grep TABLE_PREFIX

# 3. 检查SQL脚本
cat modules/my-feature/database/myfeature_tables.sql
```

**解决方案**：
```bash
# 手动创建表
docker exec postgres_master psql -U admin -d postgres <<EOF
CREATE TABLE site3__my_feature_data (
    id SERIAL PRIMARY KEY,
    -- ... 其他字段
);
GRANT ALL PRIVILEGES ON site3__my_feature_data TO site3_user;
EOF
```

### 问题4: TypeScript编译错误

**症状**：`npm run build` 失败

**排查步骤**：
```bash
# 1. 检查TypeScript错误
cd backend
npm run build 2>&1 | tee build-error.log

# 2. 检查类型导入
grep "import.*from" modules/my-feature/backend/**/*.ts
```

**解决方案**：
1. 修复类型错误
2. 确保所有导入路径正确
3. 检查 `tsconfig.json` 配置

### 问题5: 前端组件加载失败

**症状**：页面显示"加载中"但不渲染

**排查步骤**：
```bash
# 1. 检查浏览器控制台错误
# 2. 检查组件路径
ls -la modules/my-feature/frontend/pages/

# 3. 检查懒加载配置
cat modules/my-feature/module.config.ts | grep "component"
```

**解决方案**：
1. 确保组件正确导出：`export const MyFeaturePage`
2. 检查导入路径：`./frontend/pages/MyFeaturePage`
3. 添加错误边界组件捕获加载错误

---

## 📋 快速检查清单

### 开发前检查
- [ ] 确定模块名称（kebab-case）
- [ ] 创建模块目录结构
- [ ] 准备数据库表设计（如需要）
- [ ] 规划前端路由路径
- [ ] 规划后端API端点

### 开发中检查
- [ ] 前端页面组件已创建
- [ ] 后端路由和控制器已创建
- [ ] module.config.ts 已配置
- [ ] 类型定义已创建
- [ ] 国际化文件已添加（如需要）

### 部署前检查
- [ ] 本地开发环境测试通过
- [ ] TypeScript编译无错误
- [ ] 前端构建成功
- [ ] 模块已注册到 ModuleRegistry
- [ ] 数据库表已创建（如需要）
- [ ] Git提交包含所有文件

### 部署后验证
- [ ] 容器启动成功
- [ ] 模块路由已注册（检查日志）
- [ ] 前端路由可访问
- [ ] API端点正常响应
- [ ] 数据库操作正常
- [ ] 完整功能测试通过

---

## 🎯 示例模块参考

### 简单示例模块
参考 `modules/example-simple/` 目录，这是一个最小化的模块示例。

### 完整功能模块
参考 `modules/color-analysis/` 目录，这是一个包含完整功能的模块示例。

### 创建自己的模块
```bash
# 使用脚本快速创建
./scripts/create-new-module.sh your-module-name

# 手动创建
mkdir -p modules/your-module-name/{frontend/{pages,components},backend/{routes,controllers,services},database}
touch modules/your-module-name/module.config.ts
```

---

## 📞 获取帮助

### 文档资源
- 📖 [程序架构总结](./程序架构总结.md)
- 🚀 [VPS部署问题处理指南](./VPS部署问题处理指南.md)
- 🗄️ [应用接入PostgreSQL总系统指南](./应用接入PostgreSQL总系统指南.md)

### 常见问题
- 路由冲突：确保路由路径唯一
- API 404：检查apiPrefix和路由注册
- 数据库错误：验证TABLE_PREFIX和表名
- CORS错误：检查ALLOWED_ORIGINS配置

---

**文档版本**: v1.0  
**最后更新**: 2025-10-03  
**维护者**: Template Team  
**适用架构**: 前后端分离 (React + Express + PostgreSQL)

**成功案例**：
- ✅ color-analysis 模块（完整功能参考）
- ✅ example-simple 模块（快速入门参考）

---

**遵循本指南，您可以在15分钟内完成一个新功能模块的接入！** 🚀

