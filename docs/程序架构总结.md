# 🏗️ 通用Web应用模板 - 程序架构总结

**版本**: 2.0.0 (通用模板版)  
**生成时间**: 2024年10月1日  
**架构类型**: 前后端分离 + 模块化 + PostgreSQL总系统

---

## 📋 目录

1. [项目概述](#项目概述)
2. [技术栈](#技术栈)
3. [架构设计](#架构设计)
4. [核心系统](#核心系统)
5. [数据库架构](#数据库架构)
6. [部署架构](#部署架构)
7. [运行流程](#运行流程)
8. [扩展机制](#扩展机制)

---

## 📖 项目概述

### 项目定位
一个**生产级通用Web应用模板**，从ColorMagic颜色分析工具演变而来，经过完整清理和重构，提供：
- ✅ 开箱即用的核心功能（认证、国际化、反馈）
- ✅ 模块化架构（可插拔业务模块）
- ✅ 一键部署方案（VPS + Docker）
- ✅ PostgreSQL总系统集成（多站点共享）
- ✅ 完整的开发和部署文档

### 核心价值
- **快速启动**：5分钟完成配置和部署
- **模块化**：业务功能独立，易于扩展
- **规范化**：符合VPS部署最佳实践
- **可扩展**：支持1-20个站点共享资源

---

## 🛠️ 技术栈

### 前端技术栈

```typescript
{
  "核心框架": "React 18",
  "语言": "TypeScript 5.0",
  "路由": "React Router DOM 6",
  "状态管理": "Zustand 4",
  "UI框架": "TailwindCSS 3.3",
  "组件库": "Radix UI",
  "表单管理": "React Hook Form 7",
  "国际化": "react-i18next 13",
  "HTTP客户端": "Axios 1.5",
  "数据获取": "TanStack Query 5",
  "构建工具": "Vite 4",
  "图标": "Lucide React"
}
```

**关键依赖**:
- `i18next` + `react-i18next`: 8种语言国际化
- `zustand`: 轻量级状态管理
- `react-router-dom`: SPA路由
- `@radix-ui/*`: 无障碍UI组件
- `tailwindcss`: 实用优先CSS框架

### 后端技术栈

```typescript
{
  "运行时": "Node.js 18+",
  "框架": "Express 4",
  "语言": "TypeScript 5.0",
  "数据库": "PostgreSQL 15",
  "ORM": "Prisma 5.0",
  "数据库驱动": "pg 8.16",
  "认证": "JWT (jsonwebtoken 9.0)",
  "密码加密": "bcrypt 5.1",
  "缓存": "Redis 4.6 (可选)",
  "图像处理": "Sharp 0.34 (已移除)",
  "日志": "Winston 3.10",
  "验证": "Joi 17.9 + Zod 3.22",
  "压缩": "compression 1.7"
}
```

**关键依赖**:
- `express`: Web框架
- `pg`: PostgreSQL客户端
- `jsonwebtoken`: JWT认证
- `bcrypt`: 密码哈希
- `redis`: 缓存（可选）
- `compression`: Gzip压缩

### 开发工具

```typescript
{
  "包管理": "npm",
  "TypeScript编译": "tsc + tsx",
  "代码检查": "ESLint 8",
  "代码格式化": "Prettier 3",
  "测试框架": "Jest 29 + Vitest",
  "API测试": "Supertest 6",
  "热重载": "tsx watch + Vite HMR",
  "容器化": "Docker + Docker Compose"
}
```

---

## 🏗️ 架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                         用户层                              │
│  (浏览器 / 移动端 / API客户端)                             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                    CDN / Cloudflare                         │
│  (DNS解析 / SSL证书 / DDoS防护 / 缓存加速)                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│               Nginx Proxy Manager (NPM)                     │
│  (反向代理 / SSL终止 / 域名路由 / 访问日志)                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
        ┌────────────┴────────────┐
        │                         │
        ▼                         ▼
┌───────────────┐         ┌───────────────┐
│   webproxy    │         │  shared_net   │
│  (外部网络)   │         │ (内部网络)    │
└───────┬───────┘         └───────┬───────┘
        │                         │
        ▼                         │
┌─────────────────────────────────┼─────────────────────────┐
│          应用容器 (siteN)       │                         │
│  ┌──────────────────────────────┼──────────────────────┐  │
│  │     前端静态文件服务         │                      │  │
│  │  (React SPA + Index.html)    │                      │  │
│  └──────────────┬───────────────┘                      │  │
│                 │                                       │  │
│                 ▼                                       │  │
│  ┌─────────────────────────────────────────────────┐   │  │
│  │            后端API服务                          │   │  │
│  │  ┌──────────────────────────────────────────┐   │   │  │
│  │  │  Express应用                             │   │   │  │
│  │  │  ├─ CORS配置 (多域名支持)                │   │   │  │
│  │  │  ├─ 速率限制                             │   │   │  │
│  │  │  ├─ 压缩中间件                           │   │   │  │
│  │  │  ├─ 认证中间件 (JWT)                     │   │   │  │
│  │  │  └─ 路由处理                             │   │   │  │
│  │  └──────────────────────────────────────────┘   │   │  │
│  │     │                                            │   │  │
│  │     ├─ /api/auth       (认证路由)              │   │  │
│  │     ├─ /api/feedback   (反馈路由)              │   │  │
│  │     ├─ /api/health     (健康检查)              │   │  │
│  │     └─ /api/{module}   (模块路由)              │   │  │
│  └─────────────────────────────────────────────────┘   │  │
└──────────────────────────┬──────────────────────────────┘  │
                           │                                  │
                           ▼                                  │
                ┌──────────────────────┐                     │
                │   缓存层 (可选)      │                     │
                │   Redis 4.6          │                     │
                └──────────────────────┘                     │
                                                              │
                           ┌──────────────────────────────────┘
                           │
                           ▼
                ┌──────────────────────────────────┐
                │   PostgreSQL总系统               │
                │   (postgres_master)              │
                │  ┌────────────────────────────┐  │
                │  │  主数据库: postgres        │  │
                │  │  ├─ unified_feedback       │  │
                │  │  ├─ site1_* 表             │  │
                │  │  ├─ site2_* 表             │  │
                │  │  └─ siteN_* 表             │  │
                │  └────────────────────────────┘  │
                │                                  │
                │  用户权限隔离:                   │
                │  ├─ site1_user → site1_* 表    │
                │  ├─ site2_user → site2_* 表    │
                │  └─ siteN_user → siteN_* 表    │
                └──────────────────────────────────┘
```

### 架构特点

#### 1. 单体容器部署
- **前端 + 后端** 打包在同一个Docker容器
- 前端构建产物复制到 `backend/frontend/dist/`
- 后端通过Express托管前端静态文件
- 简化部署，减少网络跳转

#### 2. 双网络架构
```yaml
networks:
  webproxy:      # 外部访问网络
    external: true
  shared_net:    # 内部数据库网络
    external: true
```

- **webproxy**: 连接NPM，对外提供服务
- **shared_net**: 连接postgres_master，数据库通信

#### 3. 分离式构建策略
```bash
# 前端独立构建（Docker容器中）
cd frontend
docker run --rm -v $(pwd):/app -w /app node:22-alpine sh -c "
  npm ci && npm run build
"

# 复制到后端
cp -r dist ../backend/frontend/

# 后端单阶段构建
cd backend
docker build -f Dockerfile.simple -t siteN:latest .
```

**优势**:
- ✅ 避免多阶段构建复杂性
- ✅ 构建过程清晰可控
- ✅ 便于调试和验证
- ✅ 避免"在我机器上能跑"问题

---

## 🎯 核心系统

### 1. 认证系统 (Auth System)

#### 架构设计
```
用户 → JWT认证 → 受保护API
  ├─ 注册/登录
  ├─ Token生成 (15分钟)
  ├─ RefreshToken (7天)
  ├─ 密码加密 (bcrypt)
  └─ 会话管理
```

#### 核心组件

**后端**:
```typescript
backend/src/
├── services/auth/
│   └── authService.ts           # 认证业务逻辑
├── controllers/
│   └── authController.ts        # 认证控制器
├── routes/
│   └── auth.ts                  # 认证路由
├── middleware/
│   └── auth.ts                  # JWT中间件
└── types/
    └── auth.ts                  # 类型定义
```

**前端**:
```typescript
frontend/src/
├── components/Auth/
│   ├── AuthModals.tsx           # 登录/注册弹窗
│   ├── LoginForm.tsx            # 登录表单
│   ├── RegisterForm.tsx         # 注册表单
│   └── UserProfile.tsx          # 用户资料
├── hooks/
│   └── useAuth.ts               # 认证Hook
└── types/
    └── auth.ts                  # 类型定义
```

#### 核心功能

1. **用户注册**
   - 邮箱/用户名/密码验证
   - 密码强度检查
   - 自动生成Token

2. **用户登录**
   - 邮箱/密码验证
   - 失败次数限制（5次锁定30分钟）
   - 记住我功能（RefreshToken）

3. **JWT认证**
   - AccessToken: 15分钟有效期
   - RefreshToken: 7天有效期
   - 自动刷新机制

4. **会话管理**
   - 多设备登录
   - 会话记录（IP、User-Agent）
   - 会话撤销

#### 数据表结构
```sql
-- 用户表
CREATE TABLE {prefix}_users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    display_name VARCHAR(100),
    avatar_url TEXT,
    role VARCHAR(20) DEFAULT 'user',
    subscription_type VARCHAR(20) DEFAULT 'free',
    status VARCHAR(20) DEFAULT 'active',
    failed_login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP,
    last_login TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 刷新令牌表
CREATE TABLE {prefix}_refresh_tokens (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES {prefix}_users(id),
    token VARCHAR(255) UNIQUE NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    revoked BOOLEAN DEFAULT FALSE
);
```

---

### 2. 国际化系统 (i18n System)

#### 架构设计
```
8种语言支持
├─ 土耳其语 (tr) - 默认
├─ 中文 (zh)
├─ 英语 (en)
├─ 日语 (ja)
├─ 韩语 (ko)
├─ 法语 (fr)
├─ 德语 (de)
└─ 俄语 (ru)
```

#### 核心组件

```typescript
frontend/src/i18n/
├── index.ts                     # i18n初始化
├── locales/                     # 语言文件
│   ├── tr.json                  # 土耳其语
│   ├── zh.json                  # 中文
│   ├── en.json                  # 英语
│   ├── ja.json                  # 日语
│   ├── ko.json                  # 韩语
│   ├── fr.json                  # 法语
│   ├── de.json                  # 德语
│   └── ru.json                  # 俄语
├── core/
│   ├── I18nManager.ts           # i18n管理器
│   └── LanguageProvider.tsx     # 语言提供者
└── components/
    └── LanguageSwitcher.tsx     # 语言切换器
```

#### 核心功能

1. **语言检测**
   - 优先级：localStorage > 浏览器语言 > 默认语言
   - 自动保存用户偏好

2. **动态加载**
   - 按需加载语言包
   - 减少初始加载时间

3. **实时切换**
   - 无需刷新页面
   - 立即生效

4. **翻译管理**
   - 命名空间隔离
   - 键值对组织
   - 支持插值和复数

#### 使用示例
```typescript
import { useTranslation } from 'react-i18next'

const MyComponent = () => {
  const { t, i18n } = useTranslation()
  
  return (
    <div>
      <h1>{t('welcome')}</h1>
      <button onClick={() => i18n.changeLanguage('zh')}>
        切换到中文
      </button>
    </div>
  )
}
```

---

### 3. 反馈系统 (Feedback System)

#### 架构设计
```
统一反馈表 (unified_feedback)
├─ site_id: 站点标识
├─ type: 反馈类型
├─ content: 反馈内容
└─ metadata: 附加信息
```

#### 核心组件

**后端**:
```typescript
backend/src/
├── controllers/
│   └── feedbackController.ts    # 反馈控制器
└── routes/
    └── feedback.ts              # 反馈路由
```

**前端**:
```typescript
frontend/src/components/
└── Layout/
    └── FloatingFeedback.tsx     # 浮动反馈按钮
```

#### 数据表结构
```sql
CREATE TABLE unified_feedback (
    id SERIAL PRIMARY KEY,
    site_id VARCHAR(20) NOT NULL,      -- 站点标识
    user_id INTEGER,                    -- 用户ID（可选）
    type VARCHAR(50) NOT NULL,          -- bug/feature/suggestion/other
    content TEXT NOT NULL,              -- 反馈内容
    contact_info VARCHAR(255),          -- 联系方式
    user_agent TEXT,                    -- 浏览器信息
    url TEXT,                           -- 当前页面URL
    screenshot_url TEXT,                -- 截图URL
    metadata JSONB,                     -- 附加数据
    status VARCHAR(20) DEFAULT 'pending', -- pending/reviewed/resolved
    admin_notes TEXT,                   -- 管理员备注
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_feedback_site ON unified_feedback(site_id);
CREATE INDEX idx_feedback_created ON unified_feedback(created_at DESC);
```

#### 核心功能

1. **提交反馈**
   - 支持4种类型：bug/feature/suggestion/other
   - 可选留下联系方式
   - 自动记录页面信息

2. **多站点隔离**
   - 通过`site_id`区分不同站点
   - 每个站点用户只能访问自己的反馈

3. **状态管理**
   - pending: 待处理
   - reviewed: 已审阅
   - resolved: 已解决
   - archived: 已归档

---

### 4. 缓存系统 (Cache System)

#### 架构设计
```
Redis缓存 (可选)
├─ 会话缓存
├─ API响应缓存
└─ 频率限制
```

#### 核心组件
```typescript
backend/src/services/cache/
├── redisClient.ts               # Redis客户端
└── pixelArtCache.ts            # 缓存管理器(可清理)
```

#### 配置
```typescript
// 启用缓存
ENABLE_REDIS_CACHE=true
CACHE_ENABLED=true

// Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
```

---

## 🗄️ 数据库架构

### PostgreSQL总系统架构

#### 核心概念

**单实例多站点**:
- 1个PostgreSQL实例服务所有站点（1-20个）
- 每个站点独立用户（site1_user, site2_user...）
- 每个项目独立表前缀（myproject_*, yourproject_*）

#### 架构图
```
PostgreSQL总系统 (postgres_master)
├── 数据库: postgres
│   ├── 统一反馈表
│   │   └── unified_feedback (所有站点共享)
│   │
│   ├── 站点1表
│   │   ├── site1prefix_users
│   │   ├── site1prefix_data
│   │   └── ...
│   │
│   ├── 站点2表
│   │   ├── site2prefix_users
│   │   ├── site2prefix_data
│   │   └── ...
│   │
│   └── 站点N表
│       ├── siteNprefix_users
│       ├── siteNprefix_data
│       └── ...
│
├── 用户权限
│   ├── site1_user → 只能访问 site1prefix_* 表
│   ├── site2_user → 只能访问 site2prefix_* 表
│   └── siteN_user → 只能访问 siteNprefix_* 表
│
└── 网络别名
    └── postgres_master (Docker网络别名)
```

#### 连接配置

```typescript
// 数据库配置
const dbConfig = {
  host: 'postgres_master',       // Docker网络别名
  port: 5432,
  database: 'postgres',           // 使用主数据库
  user: 'site3_user',             // 站点用户
  password: 'site3_pass',         // 站点密码
  ssl: false,                     // VPS内部不用SSL
  max: 20,                        // 连接池大小
}
```

#### 表命名规范

```sql
-- ❌ 错误：直接使用表名
CREATE TABLE users ...
CREATE TABLE data ...

-- ✅ 正确：使用项目表前缀
CREATE TABLE myproject_users ...
CREATE TABLE myproject_data ...
```

#### 权限隔离

```sql
-- 创建站点用户
CREATE USER site3_user WITH PASSWORD 'site3_pass';

-- 只授予该站点表的权限
GRANT ALL PRIVILEGES ON myproject_users TO site3_user;
GRANT ALL PRIVILEGES ON myproject_data TO site3_user;

-- 授予统一反馈表的读写权限
GRANT SELECT, INSERT, UPDATE ON unified_feedback TO site3_user;
```

---

## 🚀 部署架构

### VPS环境结构

```bash
/docker/
├── proxy/                    # Nginx Proxy Manager
│   └── docker-compose.yml
│
├── db_master/               # PostgreSQL总系统
│   └── docker-compose.yml
│
├── site1/                   # 站点1
│   ├── docker-compose.yml
│   └── .env
│
├── site2/                   # 站点2
│   ├── docker-compose.yml
│   └── .env
│
└── siteN/                   # 站点N
    ├── docker-compose.yml
    └── .env
```

### Docker网络配置

```bash
# 创建网络
docker network create webproxy      # 外部访问网络
docker network create shared_net    # 数据库通信网络

# 网络连接
webproxy:
  - NPM (Nginx Proxy Manager)
  - site1 容器
  - site2 容器
  - siteN 容器

shared_net:
  - postgres_master 容器
  - site1 容器
  - site2 容器
  - siteN 容器
```

### 部署流程

#### 1. 一键部署脚本

```bash
# Linux/macOS
./scripts/one-click-deploy.sh

# Windows
scripts\one-click-deploy.bat
```

#### 2. 部署步骤

```bash
步骤1: 环境预检查
  ├─ 检查Docker
  ├─ 检查配置文件
  └─ 检查站点ID

步骤2: 验证配置
  ├─ 验证必需变量
  ├─ 验证数据库配置
  └─ 验证CORS配置

步骤3: 编译TypeScript
  ├─ 检查node_modules
  ├─ 运行npm run build
  └─ 验证dist目录

步骤4: 构建前端 (分离式)
  ├─ 生成package-lock.json
  ├─ Docker容器中执行npm ci
  ├─ Docker容器中执行npm run build
  └─ 复制dist到backend/frontend/

步骤5: 构建Docker镜像
  ├─ 使用Dockerfile.simple
  ├─ 单阶段构建
  └─ 标签：siteN:latest

步骤6: 配置网络
  ├─ 创建webproxy网络
  ├─ 创建shared_net网络
  └─ 配置postgres_master别名

步骤7: 停止旧容器
  └─ docker stop && docker rm

步骤8: 启动新容器
  ├─ docker run -d
  ├─ 连接webproxy网络
  └─ 连接shared_net网络

步骤9: 健康检查
  ├─ 等待服务启动
  ├─ 检查/health端点
  ├─ 检查数据库连接
  └─ 验证CORS配置

步骤10: 显示信息
  ├─ 容器IP
  ├─ 访问URL
  └─ 后续步骤
```

### Dockerfile配置

```dockerfile
# Dockerfile.simple - 单阶段构建
FROM node:22-alpine

WORKDIR /app

# 安装生产依赖
COPY package*.json ./
RUN npm ci --only=production

# 复制编译后的代码
COPY dist ./dist

# 复制前端构建产物（已在外部构建）
COPY frontend ./frontend

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s \
    CMD node -e "require('http').get('http://localhost:3000/health')"

# 启动应用
CMD ["node", "dist/index.js"]
```

---

## 🔄 运行流程

### 请求处理流程

```
1. 用户访问 https://example.com
   │
   ▼
2. Cloudflare CDN
   ├─ DNS解析
   ├─ SSL/TLS终止
   └─ DDoS防护
   │
   ▼
3. Nginx Proxy Manager
   ├─ 域名路由: example.com → siteN:3000
   ├─ SSL证书管理
   └─ 访问日志
   │
   ▼
4. 应用容器 (siteN)
   │
   ├─ 静态文件请求 (/, /about, /assets/*)
   │  │
   │  ▼
   │  Express静态文件服务
   │  └─ 返回 frontend/dist/index.html
   │     或 frontend/dist/assets/*
   │
   └─ API请求 (/api/*)
      │
      ▼
      Express路由处理
      ├─ CORS验证
      ├─ 速率限制
      ├─ JWT认证 (如需要)
      ├─ 业务逻辑处理
      ├─ 数据库查询 (PostgreSQL)
      └─ 返回JSON响应
```

### 数据库访问流程

```
应用容器
  │
  ▼
1. 获取数据库连接
   ├─ 从连接池获取连接
   └─ 配置: host=postgres_master
  │
  ▼
2. shared_net网络
   ├─ Docker DNS解析
   └─ postgres_master → PostgreSQL容器
  │
  ▼
3. PostgreSQL认证
   ├─ 用户: site3_user
   ├─ 密码: site3_pass
   └─ 数据库: postgres
  │
  ▼
4. 权限检查
   ├─ 检查用户权限
   └─ 只能访问 myproject_* 表
  │
  ▼
5. 执行SQL查询
   ├─ SELECT * FROM myproject_users
   └─ INSERT INTO unified_feedback
  │
  ▼
6. 返回结果
   └─ 释放连接回连接池
```

### 用户认证流程

```
1. 用户登录请求
   POST /api/auth/login
   Body: { email, password, remember_me }
   │
   ▼
2. authController.login()
   │
   ▼
3. authService.login()
   ├─ 验证邮箱格式
   ├─ 查询用户 (getUserByEmail)
   ├─ 检查账户状态
   ├─ 验证密码 (bcrypt.compare)
   ├─ 重置失败次数
   └─ 更新登录信息
   │
   ▼
4. 生成Token
   ├─ AccessToken (15分钟)
   │  └─ { userId, email, username, subscription_type }
   │
   └─ RefreshToken (7天，如果remember_me=true)
      └─ 保存到refresh_tokens表
   │
   ▼
5. 返回响应
   {
     user: { id, username, email, ... },
     token: "eyJhbGc...",
     refresh_token: "eyJhbGc..." (可选)
   }
   │
   ▼
6. 前端存储Token
   ├─ localStorage.setItem('token', token)
   └─ localStorage.setItem('refresh_token', refresh_token)
   │
   ▼
7. 后续请求携带Token
   Headers: { Authorization: "Bearer eyJhbGc..." }
```

### 受保护API访问流程

```
1. 请求受保护API
   GET /api/user/profile
   Headers: { Authorization: "Bearer eyJhbGc..." }
   │
   ▼
2. JWT中间件验证
   ├─ 提取Token
   ├─ 验证签名
   ├─ 检查过期时间
   └─ 解码payload
   │
   ▼
3. 验证成功
   ├─ req.user = decodedPayload
   └─ next() → 继续处理
   │
   ▼
4. 业务逻辑
   └─ 使用req.user.userId查询数据
   │
   ▼
5. 返回响应
```

---

## 🔌 扩展机制

### 模块化架构

#### 模块目录结构

```
modules/
└── {module-name}/
    ├── frontend/
    │   ├── pages/               # 页面组件
    │   ├── components/          # 模块组件
    │   └── ...
    ├── backend/
    │   ├── routes/              # API路由
    │   ├── controllers/         # 控制器
    │   └── ...
    ├── database/
    │   └── {module}-tables.sql  # 数据库表
    ├── i18n/
    │   └── locales/             # 翻译文件
    └── module.config.ts         # 模块配置
```

#### 模块注册

```typescript
// template-config/module.registry.ts
export class ModuleRegistry {
  // 可用模块
  static availableModules = new Map<string, ModuleConfig>([
    ['example-simple', simpleConfig],
    ['my-module', myModuleConfig],  // 添加新模块
  ])
  
  // 激活的模块
  static activeModules: string[] = [
    'example-simple',
    'my-module',  // 激活新模块
  ]
}
```

#### 创建新模块

```bash
# 使用脚本创建
./scripts/create-new-module.sh my-feature

# 自动生成：
modules/my-feature/
├── frontend/pages/MyFeaturePage.tsx
├── backend/routes/myFeatureRoutes.ts
├── database/myfeature_tables.sql
├── module.config.ts
└── README.md
```

---

## 📝 总结

### 核心优势

1. **开箱即用**
   - ✅ 完整的认证系统
   - ✅ 8种语言国际化
   - ✅ 统一反馈系统
   - ✅ 一键部署脚本

2. **模块化设计**
   - ✅ 核心系统与业务分离
   - ✅ 可插拔模块架构
   - ✅ 独立的配置管理

3. **生产就绪**
   - ✅ Docker容器化
   - ✅ PostgreSQL总系统
   - ✅ 健康检查机制
   - ✅ 自动SSL证书

4. **可扩展性**
   - ✅ 支持多站点部署
   - ✅ 资源共享优化
   - ✅ 模块化扩展

### 技术亮点

- **TypeScript全栈**：类型安全，减少错误
- **React 18 + Hooks**：现代化前端架构
- **JWT认证**：无状态认证，易于扩展
- **PostgreSQL总系统**：单实例多租户，资源优化
- **Docker部署**：环境一致性，快速部署
- **分离式构建**：避免复杂性，提高可靠性

### 适用场景

1. **快速原型开发**：5分钟启动新项目
2. **SaaS多租户应用**：共享资源，独立数据
3. **国际化应用**：8种语言开箱即用
4. **模块化业务**：可插拔功能模块

---

## 🎯 Site3 部署成功案例 (2024-10-02)

### 部署信息

| 项目 | 配置值 |
|------|--------|
| 站点ID | site3 |
| 表前缀 | site3__ (双下划线) |
| 数据库用户 | site3_user |
| 域名 | game2030.top, www.game2030.top |
| 部署路径 | /docker/site3 |
| 容器名称 | site3 |
| 镜像标签 | site3:latest |

### 关键配置

#### backend/.env 配置
```env
# PostgreSQL总系统配置
DB_HOST=postgres_master
DB_PORT=5432
DB_NAME=postgres
DB_USER=site3_user
DB_PASSWORD=site3_prod_pass_2024
DB_SSL=false
DB_MAX_CONNECTIONS=20

# 站点配置
SITE_ID=site3
TABLE_PREFIX=site3__    # ⚠️ 注意：双下划线

# 应用配置
NODE_ENV=production
PORT=3000
USE_DATABASE=true

# JWT配置
JWT_SECRET=site3-jwt-secret-key-change-this-2024
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# CORS配置
ALLOWED_ORIGINS=https://game2030.top,https://www.game2030.top
FRONTEND_URL=https://game2030.top

# 时区
TZ=America/New_York

# 反馈系统
FEEDBACK_SITE_ID=site3

# 缓存配置
CACHE_ENABLED=false
ENABLE_REDIS_CACHE=false
```

### 部署流程（已验证成功）

#### 步骤1: 本地准备
```bash
# 在本地开发机器上
cd "C:\Users\Administrator.USER-20240417KK\Documents\GitHub\template A"

# 1. 确认代码修改完成
# 2. 提交到Git
git add .
git commit -m "feat: integrate PostgreSQL master system"
git push origin main
```

#### 步骤2: VPS拉取代码
```bash
# 在VPS上
cd /docker/site3

# 备份.env文件
cp backend/.env backend/.env.backup

# 拉取最新代码
git stash
git pull origin main
git stash pop

# 恢复.env文件
cp backend/.env.backup backend/.env
```

#### 步骤3: 检查编译状态
```bash
# 检查dist目录是否存在
if [ -d "backend/dist" ] && [ "$(ls -A backend/dist)" ]; then
    echo "✅ dist目录已存在，跳过编译"
    # 修改部署脚本跳过编译
    sed -i 's/npm run build/echo "使用已有dist目录"/g' scripts/one-click-deploy-postgres.sh
else
    echo "⚠️ dist目录不存在，使用Docker编译"
    cd backend
    docker run --rm -v $(pwd):/app -w /app node:22-alpine sh -c "npm install && npm run build"
    cd ..
fi
```

#### 步骤4: 执行一键部署
```bash
chmod +x scripts/one-click-deploy-postgres.sh
./scripts/one-click-deploy-postgres.sh
```

### 部署验证（全部通过✅）

```bash
# 1. 环境预检查 ✅
✅ Docker已安装: 28.4.0
✅ 环境文件存在
✅ 站点 ID: site3
✅ 表前缀: site3__
✅ 数据库主机: postgres_master

# 2. PostgreSQL连接测试 ✅
✅ postgres_master容器正在运行
✅ 数据库连接测试成功
✅ 数据库表已初始化: site3__users

# 3. 编译和构建 ✅
✅ TypeScript编译完成
✅ 前端构建完成
✅ Docker镜像构建完成: site3:latest

# 4. 网络配置 ✅
✅ 网络配置完成
✅ 已连接webproxy网络
✅ 已连接shared_net网络

# 5. 服务启动 ✅
✅ 旧容器已清理
✅ 容器启动成功: site3
✅ 可以连接到PostgreSQL总系统

# 6. 部署成功 ✅
╔═══════════════════════════════════════════════════════════════╗
║                   ✅ 部署成功！                               ║
╚═══════════════════════════════════════════════════════════════╝
```

### 关键问题解决记录

#### 问题1: 表前缀不一致
**症状**: 
```
ERROR: permission denied for table site3__users
```

**原因**: 
- `.env`文件中配置的是 `TABLE_PREFIX=site3_` (单下划线)
- 数据库中实际创建的表是 `site3__users` (双下划线)
- 导致应用查询 `site3_users` 但表名是 `site3__users`

**解决方案**:
1. 确认数据库中的实际表名：
   ```bash
   docker exec postgres_master psql -U site3_user -d postgres -c "SELECT COUNT(*) FROM site3__users;"
   ```

2. 修改 `.env` 文件匹配实际表名：
   ```env
   TABLE_PREFIX=site3__  # 改为双下划线
   ```

3. 验证配置：
   ```bash
   grep "TABLE_PREFIX" backend/.env
   # 输出: TABLE_PREFIX=site3__
   ```

**预防措施**:
- ✅ 部署前先检查数据库表名
- ✅ 确保 `.env` 中的 `TABLE_PREFIX` 与实际表名一致
- ✅ 使用验证脚本自动检查

#### 问题2: .env文件格式错误
**症状**:
```
❌ 缺少必需的环境变量: DB_USER, DB_PASSWORD, TABLE_PREFIX
```

**原因**:
- 使用 `nano` 编辑时可能保存为单行
- 环境变量读取失败

**解决方案**:
使用 `cat` 命令重新创建 `.env` 文件：
```bash
rm backend/.env
cat > backend/.env << 'EOF'
DB_HOST=postgres_master
DB_PORT=5432
# ... 每个配置单独一行
EOF
```

**预防措施**:
- ✅ 使用脚本生成 `.env` 文件
- ✅ 部署前验证文件格式
- ✅ 使用 `head -20 backend/.env` 检查格式

#### 问题3: npm编译失败
**症状**:
```
./scripts/one-click-deploy-postgres.sh: line 171: npm: command not found
```

**原因**:
- VPS上没有安装 `npm`
- 部署脚本尝试直接运行 `npm run build`

**解决方案**:
1. 检查是否已有编译产物：
   ```bash
   ls -la backend/dist/
   ```

2. 如果有，修改脚本跳过编译：
   ```bash
   sed -i 's/npm run build/echo "使用已有dist目录"/g' scripts/one-click-deploy-postgres.sh
   ```

3. 如果没有，使用Docker容器编译：
   ```bash
   cd backend
   docker run --rm -v $(pwd):/app -w /app node:22-alpine sh -c "npm install && npm run build"
   cd ..
   ```

**预防措施**:
- ✅ 本地编译并提交 `dist` 目录
- ✅ 部署脚本自动检查 `dist` 目录
- ✅ 使用Docker容器编译（推荐）

### 最佳实践总结

#### 1. 部署前检查清单
```bash
# ✅ 检查环境变量
cat backend/.env | grep -E "(SITE_ID|TABLE_PREFIX|DB_USER|DB_PASSWORD|DB_HOST|ALLOWED_ORIGINS)"

# ✅ 检查数据库表
docker exec postgres_master psql -U admin -d postgres -c "\dt site3__*"

# ✅ 检查数据库用户
docker exec postgres_master psql -U admin -d postgres -c "\du" | grep site3

# ✅ 检查权限
docker exec postgres_master psql -U admin -d postgres -c "
SELECT grantee, table_name, privilege_type 
FROM information_schema.table_privileges 
WHERE grantee = 'site3_user' AND table_name LIKE 'site3__%' 
LIMIT 10;
"

# ✅ 验证dist目录
ls -la backend/dist/ | head -10
```

#### 2. 部署流程标准化
```bash
# 标准部署流程（按顺序执行）
cd /docker/site3

# 1. 备份配置
cp backend/.env backend/.env.backup

# 2. 拉取代码
git stash
git pull origin main
git stash pop

# 3. 恢复配置
cp backend/.env.backup backend/.env

# 4. 验证配置
echo "=== 验证 .env 关键配置 ==="
cat backend/.env | grep -E "(SITE_ID|TABLE_PREFIX|DB_USER|DB_PASSWORD)"

# 5. 检查编译产物
if [ -d "backend/dist" ] && [ "$(ls -A backend/dist)" ]; then
    echo "✅ 使用已有dist目录"
    sed -i 's/npm run build/echo "使用已有dist目录"/g' scripts/one-click-deploy-postgres.sh
fi

# 6. 执行部署
./scripts/one-click-deploy-postgres.sh
```

#### 3. 配置文件规范

**backend/.env 模板**:
```env
# PostgreSQL总系统配置
DB_HOST=postgres_master          # 固定值
DB_PORT=5432                     # 固定值
DB_NAME=postgres                 # 固定值
DB_USER=site3_user               # 根据站点修改
DB_PASSWORD=your_password_here   # 必须修改
DB_SSL=false                     # VPS内部通信
DB_MAX_CONNECTIONS=20            # 推荐值

# 站点配置（⚠️ 关键配置）
SITE_ID=site3                    # 站点标识
TABLE_PREFIX=site3__             # ⚠️ 必须与数据库实际表名一致！

# 应用配置
NODE_ENV=production
PORT=3000
USE_DATABASE=true

# JWT配置（⚠️ 生产环境必须修改）
JWT_SECRET=your-super-secret-jwt-key-change-this
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# CORS配置（⚠️ 必须配置实际域名）
ALLOWED_ORIGINS=https://yourdomain.com,https://www.yourdomain.com
FRONTEND_URL=https://yourdomain.com

# 时区
TZ=America/New_York

# 反馈系统
FEEDBACK_SITE_ID=site3

# 缓存配置
CACHE_ENABLED=false
ENABLE_REDIS_CACHE=false
```

### 预防式处理建议

#### 1. 代码级预防
- ✅ 使用环境变量配置表前缀
- ✅ 启动时验证数据库连接
- ✅ 启动时验证表是否存在
- ✅ 添加健康检查端点

#### 2. 部署脚本增强
```bash
# 在部署脚本中添加：
# 1. 表前缀验证
# 2. 数据库连接测试
# 3. 表存在性检查
# 4. 权限验证
```

#### 3. 文档完善
- ✅ 记录常见问题和解决方案
- ✅ 提供标准配置模板
- ✅ 更新部署检查清单

### 后续工作

#### NPM配置（下一步）
1. 登录 NPM: `http://YOUR_VPS_IP:81`
2. 添加代理主机:
   - Domain: game2030.top, www.game2030.top
   - Forward Hostname: site3
   - Forward Port: 3000
3. 申请SSL证书
4. 测试访问: https://game2030.top

#### 监控和维护
```bash
# 查看日志
docker logs site3 -f

# 检查容器状态
docker ps | grep site3

# 检查数据库连接
docker exec site3 nc -zv postgres_master 5432

# 查看反馈数据
docker exec postgres_master psql -U site3_user -d postgres -c \
  "SELECT * FROM unified_feedback WHERE site_id='site3' LIMIT 5;"
```

---

## 🔐 Site3 新认证系统重构案例 (2025-10-02)

### 背景

**问题症状**：
```
注册失败: Error: relation "users" does not exist
ValidationError: The 'X-Forwarded-For' header is set but the Express 'trust proxy' setting is false
```

**根本原因**：
1. ❌ 旧认证系统硬编码表名 `users`，未使用 `TABLE_PREFIX` 环境变量
2. ❌ Express应用未启用 `trust proxy`，导致在Nginx代理后无法正确识别客户端IP
3. ❌ PostgreSQL数据库中实际表名是 `site3__users`，但代码查询 `users` 表

---

### 解决方案：完全重写认证系统

#### 新认证系统架构

**核心设计原则**：
- ✅ 100% 基于环境变量驱动（TABLE_PREFIX）
- ✅ 代码中绝不硬编码表名
- ✅ 支持 PostgreSQL 总系统的多站点架构
- ✅ 启用 Express trust proxy（适配Nginx反向代理）

**新增文件**：
```typescript
backend/src/
├── config/
│   └── tables.ts                  # 🆕 表名配置（使用TABLE_PREFIX）
├── services/auth/
│   └── authService.ts             # ♻️ 重写（使用AUTH_TABLES）
├── controllers/
│   └── authController.ts          # ♻️ 重写（新验证逻辑）
├── routes/
│   └── auth.ts                    # ♻️ 重写（动态路由注册）
├── middleware/
│   └── auth.ts                    # ♻️ 重写（JWT验证）
└── initAuthSystem.ts              # 🆕 认证系统初始化
```

#### 关键代码实现

**1. 表名配置（backend/src/config/tables.ts）**：
```typescript
// 获取表前缀（从环境变量）
const TABLE_PREFIX = process.env.TABLE_PREFIX || '';

// 验证表前缀
if (!TABLE_PREFIX) {
  console.warn('⚠️ TABLE_PREFIX 未设置，将使用无前缀的表名（不推荐）');
}

console.log(`📊 数据库表前缀: "${TABLE_PREFIX}"`);

// 认证相关表名
export const AUTH_TABLES = {
  USERS: `${TABLE_PREFIX}users`,
  REFRESH_TOKENS: `${TABLE_PREFIX}refresh_tokens`,
} as const;
```

**2. 认证服务（backend/src/services/auth/authService.ts）**：
```typescript
import { AUTH_TABLES } from '../../config/tables';

export class AuthService {
  async register(data: RegisterData) {
    // ✅ 使用环境变量配置的表名
    const query = `
      INSERT INTO ${AUTH_TABLES.USERS} 
        (username, email, password_hash, ...)
      VALUES ($1, $2, $3, ...)
      RETURNING id, username, email, ...
    `;
    
    console.log(`💾 插入用户到表: ${AUTH_TABLES.USERS}`);
    const result = await this.pool.query(query, values);
    // 实际执行: INSERT INTO site3__users ...
  }
}
```

**3. Express主入口（backend/src/index.ts）**：
```typescript
import { initAuthSystem } from './initAuthSystem';
import { databaseService } from './services/database/databaseServiceFactory';
import { PostgreSQLService } from './services/database/postgresService';

const app = express();

// ⚙️ 启用 trust proxy - 因为应用在 Nginx 代理后面
app.set('trust proxy', 1);

// 在数据库初始化后，动态注册认证路由
async function initializeServices() {
  await initializeDatabaseService();
  const dbInfo = getDatabaseServiceInfo();
  
  if (dbInfo.type === 'postgresql' && databaseService instanceof PostgreSQLService) {
    console.log('🔐 初始化认证系统...');
    const { authRouter } = initAuthSystem(databaseService.pool);
    app.use('/api/auth', authRouter);
    console.log('✅ 新认证系统初始化完成');
    console.log(`📊 数据库表前缀: "${process.env.TABLE_PREFIX || '(无)'}"`);
  }
}
```

---

### 部署流程

#### 第1步：本地编译

```bash
cd backend
npm run build
# 确保编译成功，无TypeScript错误
```

#### 第2步：Git提交

```bash
git add backend/src backend/dist
git commit -m "feat: 重写认证系统 - 完全基于TABLE_PREFIX环境变量"
git push origin main
```

#### 第3步：VPS部署

```bash
# 1. SSH连接到VPS
ssh root@YOUR_VPS_IP

# 2. 进入项目目录
cd /docker/site3

# 3. 备份.env文件（重要！）
cp backend/.env backend/.env.backup.$(date +%Y%m%d_%H%M%S)
cp backend/.env backend/.env.backup

# 4. 停止并删除旧容器
docker stop site3
docker rm site3
docker rmi site3:latest

# 5. 拉取最新代码
git pull origin main

# 6. 验证.env配置
cat backend/.env | grep -E "(TABLE_PREFIX|DB_USER|ALLOWED_ORIGINS)"

# 7. 一键部署
./scripts/one-click-deploy-postgres.sh
```

#### 第4步：验证部署

```bash
# 查看启动日志
docker logs site3 --tail 100

# 应该看到：
# 📊 数据库表前缀: "site3__"
# 📋 当前数据库表配置:
#   - 用户表: site3__users
#   - 刷新令牌表: site3__refresh_tokens
# 🔐 认证服务初始化完成
#   - 使用表: site3__users
#   - Token 有效期: 15m
# ✅ 新认证系统初始化完成
```

---

### 部署过程中的挑战

#### 挑战1：VPS磁盘空间100%满

**症状**：
```
could not extend file "base/5/16583": No space left on device
```

**原因分析**：
- 磁盘使用：30G / 30G (100%)
- `/var/lib/docker`: 25G（大量未使用的镜像）
- `/var/log`: 1.3G（系统日志）
- 15+个悬空镜像（`<none>`标签）= 15-20GB

**解决方案**：
```bash
# 1. 清理悬空镜像
docker image prune -a -f
# 释放：15.29GB

# 2. 清理系统日志
journalctl --vacuum-size=100M
find /var/log -type f -name "*.log" -exec truncate -s 0 {} \;
# 释放：1.3GB

# 3. 删除空白站点（site10-20）
for i in {10..20}; do
  docker stop site$i 2>/dev/null
  docker rm site$i 2>/dev/null
  rm -rf /docker/site$i
done
# 释放：0.1GB

# 4. 清理Docker缓存
docker builder prune -a -f
apt clean

# 总计释放：约18GB
# 结果：30G → 12G使用，18G可用
```

**预防措施**：
- ✅ 定期清理未使用的Docker镜像
- ✅ 限制Docker容器日志大小
- ✅ 配置日志轮转策略
- ✅ 监控磁盘使用率

---

### 部署验证结果

#### ✅ 系统启动日志

```
🗄️ 使用PostgreSQL数据库服务
📊 数据库配置: {
  host: 'postgres_master',
  port: '5432',
  database: 'postgres',
  user: 'site3_user',
  ssl: false
}
📊 数据库表前缀: "site3__"
📋 当前数据库表配置:
  - 用户表: site3__users
  - 刷新令牌表: site3__refresh_tokens
🔧 开始初始化服务...
🗄️ 初始化数据库服务...
✅ PostgreSQL连接测试成功
✅ 数据库服务已初始化: POSTGRESQL
🔐 初始化认证系统...
🔐 认证服务初始化完成
  - 使用表: site3__users
  - Token 有效期: 15m
🎮 认证控制器初始化完成
🛣️ 初始化认证路由
✅ 认证路由注册完成:
  - POST /api/auth/register (公开)
  - POST /api/auth/login (公开)
  - GET  /api/auth/me (受保护)
  - POST /api/auth/logout (受保护)
✅ 新认证系统初始化完成
📊 数据库表前缀: "site3__"
🚀 Server running on port 3000
```

#### ✅ 关键验证点

1. **表前缀配置正确**：
   ```
   ✅ 📊 数据库表前缀: "site3__"
   ✅ 使用表: site3__users
   ```

2. **无trust proxy警告**：
   ```
   ✅ 没有 "X-Forwarded-For" 相关警告
   ```

3. **无表不存在错误**：
   ```
   ✅ 没有 "relation 'users' does not exist" 错误
   ```

4. **CORS配置正确**：
   ```
   ✅ 允许的CORS源: [
     'https://game2030.top',
     'https://www.game2030.top',
     /^https:\/\/.*\.vercel\.app$/
   ]
   ```

5. **注册功能测试成功**：
   ```
   ✅ 用户成功注册
   ✅ 返回正确的JWT token
   ✅ 数据正确写入 site3__users 表
   ```

---

### 技术亮点

#### 1. 环境变量驱动架构

**优势**：
- ✅ 一套代码支持多站点
- ✅ 不同环境使用不同表前缀
- ✅ 避免硬编码，提高灵活性

**实现**：
```typescript
// config/tables.ts
const TABLE_PREFIX = process.env.TABLE_PREFIX || '';

export const AUTH_TABLES = {
  USERS: `${TABLE_PREFIX}users`,
  // 运行时根据环境变量动态确定表名
  // site3: site3__users
  // site4: site4__users
  // ...
};
```

#### 2. 动态路由注册

**优势**：
- ✅ 确保数据库连接可用后再注册路由
- ✅ 避免启动时的竞态条件
- ✅ 清晰的初始化流程

**实现**：
```typescript
// index.ts
async function initializeServices() {
  await initializeDatabaseService();
  
  if (dbInfo.type === 'postgresql') {
    const { authRouter } = initAuthSystem(pool);
    app.use('/api/auth', authRouter);
  }
}
```

#### 3. Trust Proxy配置

**优势**：
- ✅ 正确识别Nginx代理后的客户端IP
- ✅ 支持速率限制按真实IP计算
- ✅ 符合生产环境最佳实践

**实现**：
```typescript
// index.ts
app.set('trust proxy', 1);
// 1 = 信任第一层代理（Nginx Proxy Manager）
```

---

### 经验总结

#### 成功因素

1. **彻底重写 vs 修补**：
   - ✅ 选择重写而非修补旧代码
   - ✅ 从设计层面解决问题
   - ✅ 代码质量和可维护性更好

2. **环境变量优先**：
   - ✅ 所有配置通过环境变量
   - ✅ 代码中零硬编码
   - ✅ 支持多环境部署

3. **完整的日志输出**：
   - ✅ 每个关键步骤都有日志
   - ✅ 便于问题诊断
   - ✅ 验证配置正确性

4. **备份优先原则**：
   - ✅ 部署前备份.env文件
   - ✅ 使用时间戳备份
   - ✅ 双重备份保险

#### 最佳实践

**1. 表名配置管理**：
```typescript
// ✅ 正确：集中管理，使用常量
import { AUTH_TABLES } from './config/tables';
const query = `SELECT * FROM ${AUTH_TABLES.USERS}`;

// ❌ 错误：硬编码表名
const query = `SELECT * FROM users`;
```

**2. 部署前检查清单**：
```bash
# ✅ 检查表前缀一致性
docker exec postgres_master psql -U admin -d postgres -c "\dt site3__*"
grep "TABLE_PREFIX" backend/.env

# ✅ 检查编译产物
ls -la backend/dist/

# ✅ 验证.env格式
head -20 backend/.env

# ✅ 测试数据库连接
docker exec site3 nc -zv postgres_master 5432
```

**3. 磁盘空间管理**：
```bash
# ✅ 定期清理（每周）
docker image prune -a -f
docker builder prune -a -f
journalctl --vacuum-size=100M

# ✅ 监控磁盘使用
df -h | grep vda1
du -sh /var/lib/docker
```

---

### 未来改进方向

1. **自动化部署检查**：
   - 添加pre-deployment验证脚本
   - 自动检查表前缀一致性
   - 验证环境变量完整性

2. **监控和告警**：
   - 磁盘空间使用率监控
   - 数据库连接池监控
   - API错误率监控

3. **文档完善**：
   - 标准化部署SOP
   - 常见问题知识库
   - 故障排查手册

---

## 📊 部署记录汇总

| 日期 | 站点 | 类型 | 状态 | 关键问题 | 解决方案 |
|------|------|------|------|---------|---------|
| 2024-10-02 | Site3 | 初始部署 | ✅ 成功 | TABLE_PREFIX不一致 | 修正.env配置 |
| 2025-10-02 | Site3 | 认证系统重构 | ✅ 成功 | 硬编码表名 + trust proxy | 完全重写 + 启用trust proxy |

---

**文档版本**: 2.0  
**更新时间**: 2025-10-02  
**维护者**: Template Team  
**最后部署**: Site3 新认证系统 - 2025-10-02 (成功✅)

